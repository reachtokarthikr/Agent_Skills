---
name: dotnet
description: Use this skill whenever the user wants to create, build, debug, or work with .NET applications. Triggers include any mention of '.NET', 'C#', 'ASP.NET', 'Blazor', 'Web API', '.NET MAUI', 'WPF', 'console app', or requests to build backend services, REST APIs, microservices, or desktop applications using Microsoft's .NET ecosystem. Also use when scaffolding projects, writing unit tests with xUnit/NUnit/MSTest, configuring dependency injection, working with middleware, or setting up CI/CD for .NET projects. ALL database access MUST use stored procedures via Dapper — never inline SQL, never Entity Framework. Do NOT use for Node.js, Python, Java, or other non-.NET backend frameworks.
---

# .NET Development Skill

This skill guides the creation of professional, production-grade .NET applications following Microsoft's recommended patterns and modern C# best practices.

The user provides requirements for a .NET project: an API, service, console app, library, Blazor app, or other .NET workload. They may include context about architecture, target framework, or deployment constraints.

---

## Request Tracking — Two IDs Across Every Layer

Every request carries **two tracking IDs** end-to-end (UI → API → DB → Response):

| ID | Purpose | Lifecycle |
|----|---------|-----------|
| **CorrelationId** | Groups all requests in a user session/flow | Generated by UI once per flow, sent via `X-Correlation-Id` header |
| **RequestId** | Identifies one individual API call | Generated by API middleware per request, returned via `X-Request-Id` header |

**Both IDs appear in**: HTTP response headers, structured logs (Serilog), SP parameters, error responses, and success responses. On unhandled exceptions, the API returns a clean error body with `requestId` so the customer can report it — **never expose stack traces or internal details**.

---

## MANDATORY: Stored Procedures Only — No Inline Queries

**RULE: ALL database access MUST go through stored procedures. No exceptions.**

- **NEVER use inline SQL** — no raw SQL strings, no `connection.QueryAsync<T>("SELECT ...")`, no ad-hoc queries
- **NEVER use Entity Framework / EF Core** — no DbContext, no LINQ-to-SQL, no migrations, no DbSet
- **NEVER use Dapper inline queries** — Dapper is used ONLY to call stored procedures via `CommandType.StoredProcedure`
- **ALL reads go through `_Get` procedures** — GETBYID, GETALL, GETFILTER
- **ALL writes go through `_Manage` procedures** — INSERT, UPDATE, DELETE
- **Use `SpHelper`** as the single data access layer — every SP call flows through `SpHelper.WithTracking()`

**Why?**
- Stored procedures are the **single source of truth** for all business logic and data access
- All logging, validation, duplicate checks, and audit trails live inside the SP
- No SQL logic leaks into the application layer
- Performance: execution plans are cached, permissions are granular per SP
- Security: application user only needs EXECUTE permission on SPs, never direct table access

**If you need a new query, create a new stored procedure. Do NOT write inline SQL.**

---

## Environment Setup

```bash
dotnet --version
```

If not installed:

```bash
wget https://dot.net/v1/dotnet-install.sh -O dotnet-install.sh
chmod +x dotnet-install.sh
./dotnet-install.sh --channel 8.0
export DOTNET_ROOT=$HOME/.dotnet
export PATH=$PATH:$DOTNET_ROOT:$DOTNET_ROOT/tools
```

Prefer **.NET 8** (LTS) unless the user specifies a different version. Use **.NET 9** if explicitly requested.

---

## Project Scaffolding

```bash
# Web API
dotnet new webapi -n MyApi -o src/MyApi

# Console app
dotnet new console -n MyApp -o src/MyApp

# Class library
dotnet new classlib -n MyLib -o src/MyLib

# Solution file (multi-project)
dotnet new sln -n MySolution
dotnet sln add src/MyApi/MyApi.csproj
dotnet sln add src/MyLib/MyLib.csproj
```

### Project Structure

```
MySolution/
├── MySolution.sln
├── src/
│   ├── MyApi/                    # Web API / Entry point
│   │   ├── Controllers/
│   │   ├── Middleware/
│   │   │   ├── TrackingMiddleware.cs       ★ generates/extracts IDs
│   │   │   └── GlobalExceptionMiddleware.cs ★ catches unhandled errors
│   │   ├── Extensions/
│   │   ├── Program.cs
│   │   └── appsettings.json
│   ├── MyApp.Core/               # Domain / Business logic
│   │   ├── Entities/
│   │   ├── Interfaces/
│   │   ├── DTOs/
│   │   ├── Services/
│   │   ├── Exceptions/
│   │   └── Tracking/
│   │       └── TrackingContext.cs           ★ holds both IDs per request
│   └── MyApp.Infrastructure/     # Data access / External services
│       ├── Data/
│       │   └── SpHelper.cs                 ★ passes both IDs to every SP
│       ├── Repositories/
│       └── Services/
├── tests/
│   ├── MyApp.UnitTests/
│   └── MyApp.IntegrationTests/
└── Directory.Build.props
```

---

## C# Coding Standards

### Modern C# Conventions (C# 12+)

- **File-scoped namespaces**: `namespace MyApp.Services;`
- **Primary constructors** for DI: `public class UserService(IUserRepository repo)`
- **Record types** for DTOs: `public record UserDto(string Name, string Email);`
- **Pattern matching** over type checks and casts
- **`required` keyword** for mandatory init properties
- **Collection expressions**: `int[] nums = [1, 2, 3];`
- **Raw string literals**: `"""..."""`
- **Prefer `var`** when type is obvious from right-hand side
- **Nullable reference types** — ensure `<Nullable>enable</Nullable>` in .csproj

### Naming Conventions

| Element               | Convention        | Example                    |
|-----------------------|-------------------|----------------------------|
| Classes / Records     | PascalCase        | `UserService`              |
| Interfaces            | I + PascalCase    | `IUserRepository`          |
| Methods               | PascalCase        | `GetUserByIdAsync`         |
| Properties            | PascalCase        | `FirstName`                |
| Private fields        | _camelCase        | `_userRepository`          |
| Parameters / Locals   | camelCase         | `userId`                   |
| Constants             | PascalCase        | `MaxRetryCount`            |
| Async methods         | Suffix with Async | `FetchDataAsync`           |

### Error Handling

- **Custom exception types** for domain errors (`NotFoundException`, `ValidationException`)
- **Global exception handling middleware** in APIs — never leak raw exceptions
- **Result pattern** (`Result<T>`) for expected failures in service layers
- `try-catch` around external I/O (database, HTTP, file system)
- Structured logging via Serilog or Microsoft.Extensions.Logging

---

## TrackingContext — Holds Both IDs Per Request

```csharp
namespace MyApp.Core.Tracking;

/// <summary>
/// Scoped service that carries CorrelationId + RequestId through the entire request pipeline.
/// Registered as Scoped so it lives for the duration of one HTTP request.
/// </summary>
public class TrackingContext
{
    /// <summary>Groups related requests in a user session/flow.</summary>
    public Guid CorrelationId { get; set; } = Guid.NewGuid();

    /// <summary>Unique identifier for this single request.</summary>
    public Guid RequestId { get; set; } = Guid.NewGuid();
}
```

---

## TrackingMiddleware — Extracts/Generates IDs

```csharp
namespace MyApi.Middleware;

/// <summary>
/// Reads X-Correlation-Id from the incoming request (or generates one).
/// Always generates a fresh X-Request-Id.
/// Sets both on TrackingContext + response headers + Serilog LogContext.
/// </summary>
public class TrackingMiddleware(RequestDelegate next)
{
    public async Task InvokeAsync(HttpContext context, TrackingContext tracking)
    {
        // CorrelationId: use from header if present, else generate
        if (context.Request.Headers.TryGetValue("X-Correlation-Id", out var corrHeader)
            && Guid.TryParse(corrHeader, out var corrId))
        {
            tracking.CorrelationId = corrId;
        }

        // RequestId: always generate fresh (API is the source of truth)
        tracking.RequestId = Guid.NewGuid();

        // Set response headers so UI can read them
        context.Response.OnStarting(() =>
        {
            context.Response.Headers["X-Correlation-Id"] = tracking.CorrelationId.ToString();
            context.Response.Headers["X-Request-Id"] = tracking.RequestId.ToString();
            return Task.CompletedTask;
        });

        // Push to Serilog LogContext so every log line includes both IDs
        using (Serilog.Context.LogContext.PushProperty("CorrelationId", tracking.CorrelationId))
        using (Serilog.Context.LogContext.PushProperty("RequestId", tracking.RequestId))
        {
            await next(context);
        }
    }
}
```

---

## GlobalExceptionMiddleware — Clean Error Responses

**CRITICAL**: On unhandled exceptions, NEVER expose stack traces or internal details. Return a clean JSON body with `requestId` so the customer can report it.

```csharp
namespace MyApi.Middleware;

public class GlobalExceptionMiddleware(RequestDelegate next, ILogger<GlobalExceptionMiddleware> logger)
{
    public async Task InvokeAsync(HttpContext context, TrackingContext tracking)
    {
        try
        {
            await next(context);
        }
        catch (Exception ex)
        {
            logger.LogError(ex,
                "Unhandled exception | CorrelationId={CorrelationId} | RequestId={RequestId} | Path={Path}",
                tracking.CorrelationId, tracking.RequestId, context.Request.Path);

            context.Response.StatusCode = ex switch
            {
                KeyNotFoundException => StatusCodes.Status404NotFound,
                ValidationException => StatusCodes.Status400BadRequest,
                UnauthorizedAccessException => StatusCodes.Status401Unauthorized,
                _ => StatusCodes.Status500InternalServerError
            };

            context.Response.ContentType = "application/json";

            // ★ Standard error response — UI reads requestId to show on error screen
            var errorResponse = new
            {
                success = false,
                message = context.Response.StatusCode == 500
                    ? "An unexpected error occurred. Please contact support with the reference ID below."
                    : ex.Message,
                correlationId = tracking.CorrelationId,
                requestId = tracking.RequestId,
                statusCode = context.Response.StatusCode,
                timestamp = DateTime.UtcNow
            };

            await context.Response.WriteAsJsonAsync(errorResponse);
        }
    }
}
```

---

## ApiResponse Wrapper

```csharp
namespace MyApp.Core.DTOs;

/// <summary>
/// Standard API response wrapper. Every endpoint returns this.
/// Both IDs are always included so the UI can display RequestId on errors.
/// </summary>
public record ApiResponse<T>
{
    public bool Success { get; init; }
    public T? Data { get; init; }
    public string? Message { get; init; }
    public Guid CorrelationId { get; init; }
    public Guid RequestId { get; init; }

    public static ApiResponse<T> Ok(T data, TrackingContext tracking) => new()
    {
        Success = true, Data = data,
        CorrelationId = tracking.CorrelationId, RequestId = tracking.RequestId
    };

    public static ApiResponse<T> Fail(string message, TrackingContext tracking) => new()
    {
        Success = false, Message = message,
        CorrelationId = tracking.CorrelationId, RequestId = tracking.RequestId
    };
}

public record PagedApiResponse<T> : ApiResponse<IEnumerable<T>>
{
    public int TotalRecords { get; init; }
    public int PageNumber { get; init; }
    public int PageSize { get; init; }
    public int TotalPages { get; init; }
}
```

---

## ASP.NET Core Web API Best Practices

### Program.cs — Middleware Registration Order

```csharp
var builder = WebApplication.CreateBuilder(args);

// Serilog with enrichers for tracking IDs
builder.Host.UseSerilog((ctx, lc) => lc
    .ReadFrom.Configuration(ctx.Configuration)
    .Enrich.FromLogContext()                              // ★ picks up CorrelationId + RequestId
    .WriteTo.Console(outputTemplate:
        "[{Timestamp:HH:mm:ss} {Level:u3}] {Message:lj} " +
        "| CorrelationId={CorrelationId} | RequestId={RequestId}{NewLine}{Exception}"));

// Services
builder.Services.AddScoped<TrackingContext>();             // ★ one per request
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
builder.Services.AddInfrastructure(builder.Configuration); // registers SpHelper + repos

var app = builder.Build();

// ★ Middleware order matters:
app.UseMiddleware<GlobalExceptionMiddleware>();  // 1. catch all errors (outermost)
app.UseMiddleware<TrackingMiddleware>();          // 2. set up tracking IDs
app.UseSerilogRequestLogging();                  // 3. log HTTP requests with IDs

if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();
app.UseAuthentication();
app.UseAuthorization();
app.MapControllers();
app.Run();
```

### Key API Principles

- Always accept `CancellationToken` in async controller actions
- Use `[ApiController]` for automatic model validation
- Return `IActionResult` or `ActionResult<T>` with proper status codes
- Always wrap responses in `ApiResponse<T>` with tracking IDs
- Add API versioning for public-facing APIs
- Enable CORS only for specific origins, never wildcard in production

---

## Calling Stored Procedures — SpHelper with Tracking (ONLY Data Access Pattern)

**This is the ONLY way to access the database.** No inline SQL, no EF Core, no raw queries.

### SpHelper — Passes Both IDs to Every SP

```csharp
using System.Data;
using Dapper;
using Microsoft.Data.SqlClient;
using MyApp.Core.Tracking;

namespace MyApp.Infrastructure.Data;

/// <summary>
/// Central helper for calling SPs. Automatically injects CorrelationId + RequestId
/// into every SP call so the DB can log them in log.RequestLog.
/// </summary>
public class SpHelper(string connectionString, TrackingContext tracking)
{
    /// <summary>Adds tracking params to any DynamicParameters.</summary>
    private DynamicParameters WithTracking(DynamicParameters? p = null)
    {
        p ??= new DynamicParameters();
        p.Add("CorrelationId", tracking.CorrelationId, DbType.Guid);
        p.Add("RequestId", tracking.RequestId, DbType.Guid);
        return p;
    }

    /// <summary>Execute a _Manage proc (INSERT/UPDATE/DELETE) and return the affected record.</summary>
    public async Task<T?> ManageAsync<T>(string spName, DynamicParameters parameters, CancellationToken ct = default)
    {
        var p = WithTracking(parameters);
        await using var conn = new SqlConnection(connectionString);
        return await conn.QueryFirstOrDefaultAsync<T>(
            new CommandDefinition(spName, p, commandType: CommandType.StoredProcedure, cancellationToken: ct));
    }

    /// <summary>Execute a _Get proc with GETBYID and return a single record.</summary>
    public async Task<T?> GetByIdAsync<T>(string spName, int id, CancellationToken ct = default)
    {
        var p = WithTracking();
        p.Add("Action", "GETBYID");
        p.Add("Id", id);
        await using var conn = new SqlConnection(connectionString);
        return await conn.QueryFirstOrDefaultAsync<T>(
            new CommandDefinition(spName, p, commandType: CommandType.StoredProcedure, cancellationToken: ct));
    }

    /// <summary>Execute a _Get proc with GETALL/GETFILTER and return TotalRecords + paged data.</summary>
    public async Task<(int Total, Guid CorrId, Guid ReqId, IEnumerable<T> Data)> GetListAsync<T>(
        string spName, DynamicParameters parameters, CancellationToken ct = default)
    {
        var p = WithTracking(parameters);
        await using var conn = new SqlConnection(connectionString);
        await using var multi = await conn.QueryMultipleAsync(
            new CommandDefinition(spName, p, commandType: CommandType.StoredProcedure, cancellationToken: ct));

        var summary = await multi.ReadFirstAsync<dynamic>();
        var data = await multi.ReadAsync<T>();
        return ((int)summary.TotalRecords, (Guid)summary.CorrelationId, (Guid)summary.RequestId, data);
    }

    /// <summary>Execute a _Get GETBYID with child result sets (e.g., Order + OrderDetails).</summary>
    public async Task<(TParent? Parent, IEnumerable<TChild> Children)> GetWithChildrenAsync<TParent, TChild>(
        string spName, int id, CancellationToken ct = default)
    {
        var p = WithTracking();
        p.Add("Action", "GETBYID");
        p.Add("Id", id);
        await using var conn = new SqlConnection(connectionString);
        await using var multi = await conn.QueryMultipleAsync(
            new CommandDefinition(spName, p, commandType: CommandType.StoredProcedure, cancellationToken: ct));
        return (await multi.ReadFirstOrDefaultAsync<TParent>(), await multi.ReadAsync<TChild>());
    }
}
```

### Repository Example — Users

```csharp
public interface IUserRepository
{
    Task<UserDto?> ManageAsync(string action, UserManageRequest request, int userId, CancellationToken ct = default);
    Task<UserDto?> GetByIdAsync(int id, CancellationToken ct = default);
    Task<PagedResult<UserDto>> GetListAsync(UserFilterRequest filter, CancellationToken ct = default);
}

public class UserRepository(SpHelper db) : IUserRepository
{
    private const string ManageSp = "app.Users_Manage";
    private const string GetSp    = "app.Users_Get";

    public async Task<UserDto?> ManageAsync(string action, UserManageRequest request, int userId, CancellationToken ct)
    {
        var p = new DynamicParameters();
        p.Add("Action", action);
        p.Add("Id", request.Id);
        p.Add("FirstName", request.FirstName);
        p.Add("LastName", request.LastName);
        p.Add("Email", request.Email);
        p.Add("Phone", request.Phone);
        p.Add("IsActive", request.IsActive);
        p.Add("UserId", userId);
        p.Add("OutputId", dbType: DbType.Int32, direction: ParameterDirection.Output);
        // ★ CorrelationId + RequestId injected automatically by SpHelper.WithTracking()
        return await db.ManageAsync<UserDto>(ManageSp, p, ct);
    }

    public Task<UserDto?> GetByIdAsync(int id, CancellationToken ct) =>
        db.GetByIdAsync<UserDto>(GetSp, id, ct);

    public async Task<PagedResult<UserDto>> GetListAsync(UserFilterRequest filter, CancellationToken ct)
    {
        var p = new DynamicParameters();
        p.Add("Action", string.IsNullOrEmpty(filter.SearchText) ? "GETALL" : "GETFILTER");
        p.Add("SearchText", filter.SearchText);
        p.Add("IsActive", filter.IsActive ?? true);
        p.Add("SortColumn", filter.SortColumn ?? "Id");
        p.Add("SortDirection", filter.SortDirection ?? "ASC");
        p.Add("PageNumber", filter.PageNumber);
        p.Add("PageSize", filter.PageSize);

        var (total, _, _, data) = await db.GetListAsync<UserDto>(GetSp, p, ct);
        return new PagedResult<UserDto>(data, total, filter.PageNumber, filter.PageSize);
    }
}
```

### DTOs and Common Models

```csharp
public record UserDto(int Id, string FirstName, string LastName, string Email, string? Phone,
    bool IsActive, int? CreatedBy, DateTime CreatedAt, int? ModifiedBy, DateTime? ModifiedAt,
    Guid? CorrelationId = null, Guid? RequestId = null);

public record UserManageRequest(int? Id, string? FirstName, string? LastName,
    string? Email, string? Phone, bool? IsActive);

public record PagedResult<T>(IEnumerable<T> Data, int TotalRecords, int PageNumber, int PageSize)
{
    public int TotalPages => (int)Math.Ceiling((double)TotalRecords / PageSize);
    public bool HasPrevious => PageNumber > 1;
    public bool HasNext => PageNumber < TotalPages;
}

public record FilterRequest
{
    public string? SearchText { get; init; }
    public bool? IsActive { get; init; } = true;
    public string? SortColumn { get; init; } = "Id";
    public string? SortDirection { get; init; } = "ASC";
    public int PageNumber { get; init; } = 1;
    public int PageSize { get; init; } = 20;
}

public record UserFilterRequest : FilterRequest;
```

### Controller — Returns Wrapped Response with Tracking

```csharp
[ApiController]
[Route("api/[controller]")]
public class UsersController(IUserRepository userRepo, TrackingContext tracking) : ControllerBase
{
    [HttpGet("{id:int}")]
    public async Task<IActionResult> GetById(int id, CancellationToken ct)
    {
        var user = await userRepo.GetByIdAsync(id, ct);
        return user is null
            ? NotFound(ApiResponse<UserDto>.Fail("User not found.", tracking))
            : Ok(ApiResponse<UserDto>.Ok(user, tracking));
    }

    [HttpGet]
    public async Task<IActionResult> GetList([FromQuery] UserFilterRequest filter, CancellationToken ct)
    {
        var result = await userRepo.GetListAsync(filter, ct);
        return Ok(new PagedApiResponse<UserDto>
        {
            Success = true, Data = result.Data,
            TotalRecords = result.TotalRecords, PageNumber = result.PageNumber,
            PageSize = result.PageSize, TotalPages = result.TotalPages,
            CorrelationId = tracking.CorrelationId, RequestId = tracking.RequestId
        });
    }

    [HttpPost]
    public async Task<IActionResult> Create([FromBody] UserManageRequest req, CancellationToken ct)
    {
        var user = await userRepo.ManageAsync("INSERT", req, GetCurrentUserId(), ct);
        return CreatedAtAction(nameof(GetById), new { id = user!.Id },
            ApiResponse<UserDto>.Ok(user, tracking));
    }

    [HttpPut("{id:int}")]
    public async Task<IActionResult> Update(int id, [FromBody] UserManageRequest req, CancellationToken ct)
    {
        var user = await userRepo.ManageAsync("UPDATE", req with { Id = id }, GetCurrentUserId(), ct);
        return Ok(ApiResponse<UserDto>.Ok(user!, tracking));
    }

    [HttpDelete("{id:int}")]
    public async Task<IActionResult> Delete(int id, CancellationToken ct)
    {
        await userRepo.ManageAsync("DELETE", new UserManageRequest(id, null, null, null, null, null), GetCurrentUserId(), ct);
        return Ok(ApiResponse<object>.Ok(new { deleted = true }, tracking));
    }

    private int GetCurrentUserId() => int.Parse(User.FindFirstValue(ClaimTypes.NameIdentifier) ?? "0");
}
```

### Service Registration

```csharp
public static class ServiceCollectionExtensions
{
    public static IServiceCollection AddInfrastructure(this IServiceCollection services, IConfiguration config)
    {
        var connStr = config.GetConnectionString("Default")
            ?? throw new InvalidOperationException("Connection string 'Default' not found.");

        // SpHelper needs both connection string AND scoped TrackingContext
        services.AddScoped(sp => new SpHelper(connStr, sp.GetRequiredService<TrackingContext>()));

        services.AddScoped<IUserRepository, UserRepository>();
        services.AddScoped<IProductRepository, ProductRepository>();
        services.AddScoped<IOrderRepository, OrderRepository>();
        return services;
    }
}
```

---

## Serilog Configuration (appsettings.json)

```json
{
  "Serilog": {
    "Using": ["Serilog.Sinks.Console", "Serilog.Sinks.File"],
    "MinimumLevel": { "Default": "Information" },
    "WriteTo": [
      { "Name": "Console" },
      {
        "Name": "File",
        "Args": {
          "path": "logs/app-.log",
          "rollingInterval": "Day",
          "outputTemplate": "{Timestamp:yyyy-MM-dd HH:mm:ss.fff} [{Level:u3}] {Message:lj} | CorrId={CorrelationId} | ReqId={RequestId}{NewLine}{Exception}"
        }
      }
    ],
    "Enrich": ["FromLogContext"]
  }
}
```

**Every log line includes both IDs**, making grep trivial:
```bash
grep "ReqId=f9e8d7c6" logs/app-2026-02-15.log
grep "CorrId=a1b2c3d4" logs/app-2026-02-15.log
```

---

## Entity Framework Core — NOT USED

**EF Core is NOT used in this architecture.** All database access goes through stored procedures via `SpHelper` + Dapper.

- No `DbContext`, no `DbSet<T>`, no LINQ queries, no migrations
- No `AsNoTracking()`, no `ExecuteUpdateAsync`, no Fluent API configurations
- If you need to change the schema, write an idempotent SQL migration script (see mssql SKILL.md)
- If you need a new query, create a new `_Get` stored procedure
- If you need a new write operation, add to the `_Manage` stored procedure

**The only data access pattern is: Controller → Repository → SpHelper → Stored Procedure**

---

## Dependency Injection

| Lifetime    | Use For                                      |
|-------------|----------------------------------------------|
| `Transient` | Lightweight, stateless services              |
| `Scoped`    | Per-request services (TrackingContext, SpHelper, Repositories) |
| `Singleton` | Thread-safe shared services (HttpClient, Cache) |

---

## Testing

### Test Project Setup

```bash
dotnet new xunit -n MyApp.UnitTests -o tests/MyApp.UnitTests
dotnet add tests/MyApp.UnitTests package Moq
dotnet add tests/MyApp.UnitTests package FluentAssertions
```

### Unit Test Pattern

```csharp
public class UserServiceTests
{
    private readonly Mock<IUserRepository> _repoMock = new();
    private readonly UserService _sut;

    public UserServiceTests() => _sut = new UserService(_repoMock.Object);

    [Fact]
    public async Task GetByIdAsync_WhenUserExists_ReturnsUser()
    {
        // Arrange
        var expected = new UserDto(1, "John", "Doe", "john@test.com", null, true, null, DateTime.UtcNow, null, null);
        _repoMock.Setup(r => r.GetByIdAsync(1, default)).ReturnsAsync(expected);

        // Act
        var result = await _sut.GetByIdAsync(1);

        // Assert
        result.Should().NotBeNull();
        result!.FirstName.Should().Be("John");
    }

    [Fact]
    public async Task GetByIdAsync_WhenNotFound_ReturnsNull()
    {
        _repoMock.Setup(r => r.GetByIdAsync(99, default)).ReturnsAsync((UserDto?)null);
        var result = await _sut.GetByIdAsync(99);
        result.Should().BeNull();
    }
}
```

### Testing Best Practices

- **Arrange-Act-Assert** pattern
- **Fact** for parameterless, **Theory + InlineData** for parameterized
- Name: `MethodName_Scenario_ExpectedBehavior`
- Use **WebApplicationFactory** for integration tests

---

## Configuration & Secrets

- `appsettings.json` + `appsettings.{Environment}.json`
- **Options pattern** with validation:

```csharp
builder.Services.AddOptions<DatabaseOptions>()
    .BindConfiguration("Database")
    .ValidateDataAnnotations()
    .ValidateOnStart();
```

- **Never hardcode secrets** — use User Secrets (dev), environment variables, or Key Vault (prod)

---

## Common NuGet Packages

| Purpose             | Package                                      |
|---------------------|----------------------------------------------|
| Micro ORM (SP only) | Dapper                                       |
| SQL Client          | Microsoft.Data.SqlClient                     |
| Logging             | Serilog.AspNetCore                           |
| Validation          | FluentValidation.AspNetCore                  |
| Mapping             | Mapster or AutoMapper                        |
| HTTP Resilience     | Microsoft.Extensions.Http.Polly              |
| Testing             | xUnit + Moq + FluentAssertions              |
| API Docs            | Swashbuckle.AspNetCore                       |

---

## Build & Run

```bash
dotnet restore
dotnet build --no-restore
dotnet run --project src/MyApi
dotnet test --verbosity normal
dotnet publish -c Release -o ./publish
```

---

## Output Delivery

1. **ALL database access through stored procedures** — no inline SQL, no EF Core, no raw Dapper queries
2. Every API response wraps in `ApiResponse<T>` with `correlationId` + `requestId`
3. `GlobalExceptionMiddleware` returns clean error JSON with `requestId` — **never stack traces**
4. `TrackingMiddleware` sets `X-Correlation-Id` + `X-Request-Id` response headers
5. `SpHelper.WithTracking()` auto-injects both IDs into every SP call
6. Serilog logs include both IDs on every line
7. Write all project files under `/home/claude/`
8. Ensure the project builds: `dotnet build`
9. Copy final deliverables to `/mnt/user-data/outputs/`
